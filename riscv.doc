带有 `__hsai_hal` 宏标签的类或函数是需要 HAL 实现的。

//hsai_global.hh
	void __hsai_hal hardware_abstract_init( void );
	void __hsai_hal hardware_secondary_init( void );
    void * __hsai_hal get_ra();

//process_interface.hh
	extern __hsai_hal void user_proc_init( void * proc );

	extern __hsai_hal void set_trap_frame_return_value( void * trapframe, ulong value );

	extern __hsai_hal void set_trap_frame_entry( void * trapframe, void * entry );

	extern __hsai_hal void set_trap_frame_user_sp( void * trapframe, ulong sp );

	extern __hsai_hal void set_trap_frame_arg( void * trapframe, uint arg_num, ulong value );

	extern __hsai_hal void copy_trap_frame( void * from, void * to );

	extern __hsai_hal ulong get_arg_from_trap_frame( void * trapframe, uint arg_num );

	extern __hsai_hal void user_trap_return();

	extern __hsai_hal const uint context_size;

	extern __hsai_hal void set_context_entry( void * cont, void * entry );

	extern __hsai_hal void set_context_sp( void * cont, ulong sp );

	extern __hsai_hal void * get_context_address( uint proc_gid );

//timer_interface.hh
	extern __hsai_hal ulong get_main_frequence();

	extern __hsai_hal ulong cycles_per_tick();

	extern __hsai_hal ulong get_hw_time_stamp();

	extern __hsai_hal ulong time_stamp_to_usec( ulong ts );

	extern __hsai_hal ulong usec_to_time_stamp( ulong us );

//viertual_cpu.hh
    class VirtualCpu __hsai_hal

//virtual_interrupt_manager.hh
	class VirtualInterruptManager __hsai_hal
	{
	public:
		virtual int handle_dev_intr() = 0;

	public:
		static int register_interrupt_manager( VirtualInterruptManager * im );
	};

//page.hh
    class Pte __hsai_hal

//virtual_memory
    class VirtualMemory __hsai_hal

//virtual_uart
    class VirtualUartController __hsai_hal : public CharDevice


2025.3.18 19:43
    两个方案：1.全实现 2.先做uart串口
    另外还要修改Makefile

修改EASTL
1.compiler_gcc
	编译器报告以下错误：
In file included from include/EASTL/internal/atomic/compiler/compiler.h:20,
                 from include/EASTL/internal/atomic/atomic_macros.h:61,
                 from include/EASTL/internal/atomic/atomic.h:19,
                 from include/EASTL/atomic.h:1766,
                 from source/atomic.cpp:6:
include/EASTL/internal/atomic/compiler/gcc/compiler_gcc.h:27:40: error: static assertion failed: eastl::atomic<T> where sizeof(T) == 1 must be lock-free!
   27 | static_assert(__atomic_always_lock_free(1, 0), "eastl::atomic<T> where sizeof(T) == 1 must be lock-free!");
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
include/EASTL/internal/atomic/compiler/gcc/compiler_gcc.h:28:40: error: static assertion failed: eastl::atomic<T> where sizeof(T) == 2 must be lock-free!
   28 | static_assert(__atomic_always_lock_free(2, 0), "eastl::atomic<T> where sizeof(T) == 2 must be lock-free!");
      |               ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~

这意味着 EASTL 要求当 sizeof(T) 为 1 或 2 时，std::atomic<T> 必须是无锁（lock-free）的，但编译器检查发现这些类型并不是无锁的
注释掉，通过编译
// static_assert(__atomic_always_lock_free(1, 0), "eastl::atomic<T> where sizeof(T) == 1 must be lock-free!");
// static_assert(__atomic_always_lock_free(2, 0), "eastl::atomic<T> where sizeof(T) == 2 must be lock-free!");

2.tuple
	static const Internal::ignore_t ignore;
	unused variable.注释掉，通过编译

3.eaplatform
	#error Unknown platform
	#error Unknown processor
	#error Unknown endianness
	修改为
	#define EA_PROCESSOR_RISCV_64 1
	#define EA_SYSTEM_LITTLE_ENDIAN 1
	#define EA_PLATFORM_DESCRIPTION "Linux on RISCV 64"
	//#pragma message("eaplatform in Loongarch64")

	由于loongarch版本不知道为什么能通过编译，传递的ARCH宏没有使用。所以将报错的地方改成riscv的信息。这样两个架构都能通过

4.config
	增加调试宏

11时24分完成EASTL

3月20 16时58分,使用riscv64-unknown-elf 14.2开发，根蔡老师反映，准备向组委会联系
eaplatform之后阿再来处理，看起来只有little endian宏是有意义的，学长定义的loongarch宏只用在一个调试宏上

./configure --prefix=/opt/riscv64 --with-arch=rv64gc --with-abi=lp64d --enable-languages=c,c++